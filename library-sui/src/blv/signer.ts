import { bcs } from "@mysten/sui/bcs";
import { sha256 } from "@noble/hashes/sha256";
import { SignatureScheme } from "@mysten/sui/cryptography";
import { ed25519 } from "@noble/curves/ed25519";
import { secp256k1 } from "@noble/curves/secp256k1";
import { Ed25519PublicKey } from "@mysten/sui/keypairs/ed25519";
import { Secp256k1PublicKey } from "@mysten/sui/keypairs/secp256k1";
import { Signer as BaseSigner } from "@mysten/sui/cryptography";
import { KmsSigner } from "../classes";
import { hexToUint8Array } from "./utils";

export const SignaturePayloadStruct = bcs.struct("SignaturePayloadStruct", {
    target: bcs.Address, // ID or the address of rewards pool or the  vault
    receiver: bcs.Address, // the address of reward's receiver or the person eligible for claiming funds
    amount: bcs.u64(), // quantity/amount of rewards - MUST be in 9 DECIMAL PLACES or amount that can be claimed (must be in 6 decimals)
    expiry: bcs.u64(), // timestamp till which signature is valid
    nonce: bcs.u128(), // a random number
    type: bcs.u8() // the signature payload type. Could be 1 (Rewards Claim) or 2 (Funds Claim)
});

/// The signature data that is to be send on-chain
export const SignatureStruct = bcs.struct("SignatureStruct", {
    sig: bcs.vector(bcs.u8()), // the signature generated by the signer using `SignaturePayload`
    pk: bcs.vector(bcs.u8()), // public key of the signer
    scheme: bcs.u8() // 0 if the wallet type is Secp 1 otherwise (ED25519)
});

export class Signer {
    /**
     * Provided a payload for generating reward or funds claim signature, serializes it and returns its sha 256 hash to be signed
     * @param data signature payload to be signed
     * @returns sha256 hash of serialized data payload provided as input
     */
    static getPayloadHash(data: typeof SignaturePayloadStruct.$inferType): Uint8Array {
        // take sha256 hash of the serialized data
        return sha256(SignaturePayloadStruct.serialize(data).toBytes());
    }

    /**
     * Uses the provided signer key pair to generate signature for the users to use and claim rewards or funds
     * @param signer KeyPair of the signer. The signer must be the operator/controller of the rewards pool or claims_manager of the vault
     * @param payload The payload to be signed
     * @returns serialized signature that can be provided to user to perform on-chain `claim_rewards` call.
     */
    static async sign(
        signer: BaseSigner,
        payload: typeof SignaturePayloadStruct.$inferType
    ): Promise<string> {
        // compute hash of the payload
        const hash = Signer.getPayloadHash(payload);

        // create signature
        const sig = await signer.sign(hash);

        // create signature payload
        const signature = {
            sig,
            pk: signer.getPublicKey().toRawBytes(),
            scheme: signer.getKeyScheme() == "Secp256k1" ? 0 : 1
        };

        // serialize and return the hex of the signature
        return SignatureStruct.serialize(signature).toHex();
    }

    /**
     * Uses the provided signer key pair to generate signature for the users to use and claim rewards or funds
     * @param signer KeyPair of the signer. The signer must be the operator/controller of the rewards pool or claims_manager of the vault
     * @param payload The payload to be signed
     * @returns serialized signature that can be provided to user to perform on-chain `claim_rewards` call.
     */
    static async signUsingKMS(
        signer: KmsSigner,
        payload: typeof SignaturePayloadStruct.$inferType
    ): Promise<string> {
        // compute hash of the payload
        const hash = Signer.getPayloadHash(payload);

        // create signature
        const sig = await signer.sign(hash);

        // create signature payload
        const signature = {
            sig,
            pk: signer.getPublicKey().toRawBytes(),
            scheme: signer.getKeyScheme() == "Secp256k1" ? 0 : 1
        };

        // serialize and return the hex of the signature
        return SignatureStruct.serialize(signature).toHex();
    }

    /**
     * Given an array of data bytes and serialized signature returns true if the signature is valid
     * @param signature bcs serialized signature (returned by `Signer.sign` method)
     * @param data data bytes array
     * @param payload
     * @returns True if signature is valid
     */
    static verify(
        signature: string,
        payload: typeof SignaturePayloadStruct.$inferType
    ): boolean {
        // de-serialize the signature content
        const deSig = SignatureStruct.parse(hexToUint8Array(signature));
        // get hex of the signature
        const hexSig = Buffer.from(deSig.sig).toString("hex");
        // extract signer's public key
        const pk = Uint8Array.from(deSig.pk);

        // get the payload hash that was signed
        const data = Signer.getPayloadHash(payload);

        // todo add more types!
        switch (deSig.scheme) {
            case 0: // Secp256K1
                return this.verifySECP(hexSig, sha256(data), pk);
            case 1: // ED25519
                return ed25519.verify(hexSig, data, pk);
            default:
                throw "Signature is created using invalid signer type";
        }
    }

    /**
     * Validates if the provided signature is created using the data and public key provided
     * @param signature hex encoded signature
     * @param data data bytes
     * @param publicKey public key bytes
     * @returns True if signature is valid
     */
    public static verifySECP(
        signature: string,
        data: Uint8Array,
        publicKey: Uint8Array
    ): boolean {
        const sig_r_s = secp256k1.Signature.fromCompact(signature);
        const sig_r_s_b1 = sig_r_s.addRecoveryBit(0x1);
        const recovered_pk_1 = sig_r_s_b1
            .recoverPublicKey(data)
            .toRawBytes(true)
            .toString();

        const sig_r_s_b0 = sig_r_s.addRecoveryBit(0x0);
        const recovered_pk_0 = sig_r_s_b0
            .recoverPublicKey(data)
            .toRawBytes(true)
            .toString();

        return (
            publicKey.toString() === recovered_pk_1 ||
            publicKey.toString() === recovered_pk_0
        );
    }

    public static getSuiAddressFromPublicKey(
        publicKey: string | Uint8Array,
        scheme: SignatureScheme
    ) {
        switch (scheme) {
            case "ED25519":
                return new Ed25519PublicKey(publicKey).toSuiAddress();
            case "Secp256k1":
                return new Secp256k1PublicKey(publicKey).toSuiAddress();
            default:
                throw new Error("Provided scheme is invalid");
        }
    }
}
