import {
    BigNumber,
    BigNumberable,
    OnChainCallResponse,
    TransactionBlock
} from "../../types";
import {
    IBatchTradeArgs,
    IBluefinV3OptionalParams,
    IOraclePriceUpdate
} from "../interfaces/IOnChainCalls";
import { Address, NumStr, Operator, Serialized, SupportedAssets } from "../types";
import { BCSUtils, Order } from "../utils/bcs";
import { ISignedOrder } from "../interfaces";
import { OnChainCalls } from "./on-chain-calls";

export class SequencerCalls extends OnChainCalls {
    /**
     * Create and executes internal data store transfer call
     * @param sequencer address of the new sequencer that will own ids
     * @param options Optional tx execution params
     * @returns OnChainCallResponse
     */
    async transferInternalDataStore(
        sequencer: string,
        options?: IBluefinV3OptionalParams
    ): Promise<OnChainCallResponse> {
        const txb = this.txBuilder.transferInternalDataStore(
            sequencer || this.parser.getInternalDataStore(),
            options
        );

        return this.execCall(txb, options);
    }

    /**
     * Allows the owner of internal bank to invoke the method and
     * update/deposit user funds into internal bank from external
     * @param assetSymbol Name of the asset to be deposited
     * @param from The address of the account that deposited assets in shared Asset Bank
     * @param nonce the nonce emitted during asset deposit in shared bank
     * @param sequenceHash the expected sequence hash on-chain after the tx execution
     * @param options Optional tx execution params
     * @returns OnChainCallResponse
     */
    async depositToInternalBank(
        assetSymbol: SupportedAssets,
        from: Address,
        nonce: NumStr,
        sequenceHash: string,
        options?: IBluefinV3OptionalParams
    ): Promise<OnChainCallResponse> {
        const txb = this.txBuilder.depositToInternalBank(
            assetSymbol,
            from,
            nonce,
            sequenceHash,
            options
        );

        return this.execCall(txb, options);
    }

    /**
     * Allows the sequencer to invoke withdraw call on-chain to move funds for a user
     * from the bank to user address
     * @param data serialized hex string of the withdrawal payload
     * @param signature bcs serialized signature payload generated by the user by signing the withdrawal request
     * @param sequenceHash the expected sequence hash on-chain after the tx execution
     * @param timestamp The timestamp at which withdraw was performed off-chain
     * @param options Optional tx execution params
     * @returns OnChainCallResponse
     */
    async withdrawFromBank(
        data: Serialized,
        signature: Serialized,
        oraclePrices: Array<IOraclePriceUpdate>,
        sequenceHash: string,
        timestamp: NumStr,
        options?: IBluefinV3OptionalParams
    ): Promise<OnChainCallResponse> {
        const txb = this.txBuilder.withdrawFromBank(
            data,
            signature,
            oraclePrices.map(op => op.perpetual),
            oraclePrices.map(op => new BigNumber(op.price).toFixed(0)),
            sequenceHash,
            timestamp,
            options
        );

        return this.execCall(txb, options);
    }

    /**
     * Allows the owner of internal bank to invoke the method and
     * synchronize the attributes of provided perpetual between ids and eds
     * @param perpAddress the address of the perpetual to be synced
     * @param sequenceHash the expected sequence hash on-chain after the tx execution
     * @param options Optional tx execution params
     * @returns OnChainCallResponse
     */
    async syncPerpetual(
        perpAddress: string,
        sequenceHash: string,
        options?: IBluefinV3OptionalParams
    ): Promise<OnChainCallResponse> {
        const txb = this.txBuilder.syncPerpetual(perpAddress, sequenceHash, options);

        return this.execCall(txb, options);
    }

    /**
     * Allows the sequencer to execute the authorized user call to whitelist/blacklist
     * the given user to use the account
     * @param data serialized hex string of the authorization payload
     * @param signature bcs serialized signature generate by singing the request payload data
     * @param sequenceHash the expected sequence hash on-chain after the tx execution
     * @param timestamp The timestamp at which withdraw was performed off-chain
     * @param options Optional tx execution params & timestamp - this is the time at which withdraw was performed off-chain
     * @returns OnChainCallResponse
     */
    async authorizeUser(
        data: Serialized,
        signature: Serialized,
        sequenceHash: string,
        timestamp: NumStr,
        options?: IBluefinV3OptionalParams
    ): Promise<OnChainCallResponse> {
        const txb = this.txBuilder.authorizeUser(
            data,
            signature,
            sequenceHash,
            timestamp,
            options
        );
        return this.execCall(txb, options);
    }

    /**
     * Allows sequencer to replicate asset details from external data store to internal data store
     * @param symbol the symbol of the asset
     * @param sequenceHash the expected sequence hash on-chain after the tx execution
     * @param options Optional tx execution params
     * @returns OnChainCallResponse
     */
    async syncSupportedAsset(
        symbol: string,
        sequenceHash: string,
        options?: IBluefinV3OptionalParams
    ): Promise<OnChainCallResponse> {
        const txb = this.txBuilder.syncSupportedAsset(symbol, sequenceHash, options);
        return this.execCall(txb, options);
    }

    /**
     * Allows sequencer to execute trade between two orders
     * @param makerOrder The signed maker order
     * @param takerOrder The signed taker order
     * @param quantity  The quantity to be traded
     * @param oraclePrice The list of perpetuals and their new oracle prices
     * @param sequenceHash Sequence hash
     * @param timestamp The timestamp at which withdraw was performed off-chain
     * @param options Optional tx execution params & execution time
     * @returns OnChainCallResponse
     */
    async performTrade(
        makerOrder: ISignedOrder,
        takerOrder: ISignedOrder,
        quantity: BigNumberable,
        oraclePrices: Array<IOraclePriceUpdate>,
        sequenceHash: string,
        timestamp: NumStr,
        options?: IBluefinV3OptionalParams
    ): Promise<OnChainCallResponse> {
        const txb = this.txBuilder.performTrade(
            BCSUtils.getSerializedDataBytes(makerOrder, Order),
            BCSUtils.getSerializedDataBytes(takerOrder, Order),
            makerOrder.signature,
            takerOrder.signature,
            new BigNumber(quantity).toFixed(0),
            oraclePrices.map(op => op.perpetual),
            oraclePrices.map(op => new BigNumber(op.price).toFixed(0)),
            sequenceHash,
            timestamp,
            options
        );

        return this.execCall(txb, options);
    }

    /**
     * Allows sequencer to execute liquidation trade
     * @param data The serialized liquidation payload
     * @param signature The liquidator's signature on the data payload
     * @param oraclePrice The list of perpetuals and their new oracle prices
     * @param sequenceHash Sequence hash
     * @param timestamp  The time at which liquidation was executed off-chain
     * @param options Optional tx execution params & execution time
     * @returns OnChainCallResponse
     */
    async performLiquidation(
        data: Serialized,
        signature: Serialized,
        oraclePrices: Array<IOraclePriceUpdate>,
        sequenceHash: string,
        timestamp: NumStr,
        options?: IBluefinV3OptionalParams
    ): Promise<OnChainCallResponse> {
        const txb = this.txBuilder.performLiquidation(
            data,
            signature,
            oraclePrices.map(op => op.perpetual),
            oraclePrices.map(op => new BigNumber(op.price).toFixed(0)),
            sequenceHash,
            timestamp,
            options
        );

        return this.execCall(txb, options);
    }

    /**
     * Allows sequencer to execute batch of trades
     * @param args Array of trade arguments
     * @param options Optional tx execution params & execution time
     * @returns OnChainCallResponse
     */
    async performTradeBatch(
        args: Array<IBatchTradeArgs>,
        options?: IBluefinV3OptionalParams
    ): Promise<OnChainCallResponse> {
        const txb = options?.txBlock || new TransactionBlock();

        for (const tradeArgs of args) {
            this.txBuilder.performTrade(
                BCSUtils.getSerializedDataBytes(tradeArgs.makerOrder, Order),
                BCSUtils.getSerializedDataBytes(tradeArgs.takerOrder, Order),
                tradeArgs.makerOrder.signature,
                tradeArgs.takerOrder.signature,
                new BigNumber(tradeArgs.quantity).toFixed(0),
                tradeArgs.oraclePrices.map(op => op.perpetual),
                tradeArgs.oraclePrices.map(op => new BigNumber(op.price).toFixed(0)),
                tradeArgs.sequenceHash,
                tradeArgs.timestamp,
                { ...options, txBlock: txb }
            );
        }

        return this.execCall(txb, options);
    }

    /**
     * Allows the sequencer to invoke adjust margin call on-chain for the provided signed payload
     * to add/remove margin from a user's isolated position to/from cross account
     * @param data serialized hex string of the adjust margin payload
     * @param signature bcs serialized signature payload generated by the user by signing the adjust margin request
     * @param sequenceHash the expected sequence hash on-chain after the tx execution
     * @param oraclePrices: The oracle prices of perpetuals at the time this tx was executed
     * @param timestamp  The time at which adjust margin was executed off-chain
     * @param options Optional tx execution params
     * @returns OnChainCallResponse
     */
    async adjustMargin(
        data: Serialized,
        signature: Serialized,
        oraclePrices: Array<IOraclePriceUpdate>,
        sequenceHash: string,
        timestamp: NumStr,
        options?: IBluefinV3OptionalParams
    ): Promise<OnChainCallResponse> {
        const txb = this.txBuilder.adjustMargin(
            data,
            signature,
            oraclePrices.map(op => op.perpetual),
            oraclePrices.map(op => new BigNumber(op.price).toFixed(0)),
            sequenceHash,
            timestamp,
            options
        );

        return this.execCall(txb, options);
    }

    /**
     * Allows the sequencer to invoke adjust leverage call on-chain for the provided signed payload
     * to change the leverage for provided perpetual position
     * @param data serialized hex string of the adjust leverage payload
     * @param signature bcs serialized signature payload generated by the user by signing the adjust leverage request
     * @param oraclePrices: The oracle prices of perpetuals at the time this tx was executed
     * @param sequenceHash the expected sequence hash on-chain after the tx execution
     * @param timestamp  The time at which adjust leverage was executed off-chain
     * @param options Optional tx execution params
     * @returns OnChainCallResponse
     */
    async adjustLeverage(
        data: Serialized,
        signature: Serialized,
        oraclePrices: Array<IOraclePriceUpdate>,
        sequenceHash: string,
        timestamp: NumStr,
        options?: IBluefinV3OptionalParams
    ): Promise<OnChainCallResponse> {
        const txb = this.txBuilder.adjustLeverage(
            data,
            signature,
            oraclePrices.map(op => op.perpetual),
            oraclePrices.map(op => new BigNumber(op.price).toFixed(0)),
            sequenceHash,
            timestamp,
            options
        );

        return this.execCall(txb, options);
    }

    /**
     * Create and executes transaction to synchronize the operator between eds and ids
     * @param type The type of the operator be synced
     * @param sequenceHash The sequence hash computed off-chain
     * @param options Optional tx execution params
     * @returns OnChainCallResponse
     */
    async syncOperator(
        type: Operator,
        sequenceHash: string,
        options?: IBluefinV3OptionalParams
    ): Promise<OnChainCallResponse> {
        const txb = this.txBuilder.syncOperator(type, sequenceHash, options);
        return this.execCall(txb, options);
    }

    /**
     * Create and executes transaction to set funding rate on chain
     * @param data serialized hex string of the set funding rate payload
     * @param signature bcs serialized signature payload generated by the user by signing the funding rate request
     * @param sequenceHash the expected sequence hash on-chain after the tx execution
     * @param timestamp  The time at which funding rate was set off-chain
     * @param options Optional tx execution params
     * @returns OnChainCallResponse
     */
    async setFundingRate(
        data: Serialized,
        signature: Serialized,
        sequenceHash: string,
        timestamp: NumStr,
        options?: IBluefinV3OptionalParams & { timestamp?: NumStr }
    ): Promise<OnChainCallResponse> {
        const txb = this.txBuilder.setFundingRate(
            data,
            signature,
            sequenceHash,
            timestamp,
            options
        );
        return this.execCall(txb, options);
    }

    /**
     * Create and executes transaction to apply funding rate on chain
     * @param data serialized hex string of the apply funding rate payload
     * @param sequenceHash the expected sequence hash on-chain after the tx execution
     * @param timestamp  The time at which funding rate was applied off-chain
     * @param options Optional tx execution params
     * @returns OnChainCallResponse
     */
    async applyFundingRate(
        data: Serialized,
        sequenceHash: string,
        timestamp: NumStr,
        options?: IBluefinV3OptionalParams
    ): Promise<OnChainCallResponse> {
        const txb = this.txBuilder.applyFundingRate(
            data,
            sequenceHash,
            timestamp,
            options
        );
        return this.execCall(txb, options);
    }

    /**
     * Create and executes transaction to prune table
     * @param data serialized hex string of purging table
     * @param signature bcs serialized signature payload generated by the user by signing the prune table request
     * @param sequenceHash the expected sequence hash on-chain after the tx execution
     * @param timestamp The timestamp at which table got pruned off-chain
     * @param options Optional tx execution params
     * @returns OnChainCallResponse
     */
    async pruneTable(
        data: Serialized,
        signature: Serialized,
        sequenceHash: string,
        timestamp: NumStr,
        options?: IBluefinV3OptionalParams
    ): Promise<OnChainCallResponse> {
        const txb = this.txBuilder.pruneTable(
            data,
            signature,
            sequenceHash,
            timestamp,
            options
        );
        return this.execCall(txb, options);
    }
}
